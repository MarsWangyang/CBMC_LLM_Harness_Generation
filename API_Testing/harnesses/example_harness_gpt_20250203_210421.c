/*
 * CBMC Harness generated for example.c
 * Generated by: gpt
 * Generated at: 2025-02-03 21:04:21
 */

#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <assert.h>

#define SENSOR_QUEUE_LENGTH    10
#define SENSOR_ITEM_SIZE       sizeof(uint32_t)
#define MAX_TEMPERATURE        100
#define MIN_TEMPERATURE        0
#define STACK_SIZE             configMINIMAL_STACK_SIZE * 2

extern QueueHandle_t xSensorQueue;
extern SemaphoreHandle_t xSensorMutex;
extern TaskHandle_t xSensorTaskHandle;
extern TaskHandle_t xProcessTaskHandle;

typedef struct {
    uint32_t temperature;
    uint32_t timestamp;
} SensorData_t;

static void vSensorTask(void *pvParameters);
static void vProcessingTask(void *pvParameters);
static uint32_t ulGetSensorReading(void);
static void vProcessSensorData(const SensorData_t* pxData);
bool initSystem(void);

// CBMC harness
void harness(void) {
    // Initialize system should succeed in the harness context
    assert(initSystem() == true);
    
    // Non-deterministic SensorData_t for simulating sensor task behavior
    SensorData_t nondetSensorData;
    nondetSensorData.temperature = __CPROVER_nondet_uint();
    nondetSensorData.timestamp = __CPROVER_nondet_uint();
    
    // Assumptions to ensure valid non-deterministic input
    __CPROVER_assume(nondetSensorData.temperature >= MIN_TEMPERATURE && nondetSensorData.temperature <= MAX_TEMPERATURE);
    
    // Simulate the sensor task behavior by directly sending non-deterministic SensorData_t to the queue
    BaseType_t sendResult = xQueueSend(xSensorQueue, &nondetSensorData, 0);
    assert(sendResult == pdPASS); // Assert that the send operation was successful
    
    // Call processing task function to process the data sent to the queue
    vProcessingTask(NULL); // We can call this without a real task creation
    
    // Verify memory safety properties
    assert(xSensorQueue != NULL);
    assert(xSensorMutex != NULL);
}

int main(void) {
    harness();
    return 0;
}